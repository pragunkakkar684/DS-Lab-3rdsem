$date
	Thu Aug 21 16:04:00 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module bcd_adder_tb $end
$var wire 4 ! sum [3:0] $end
$var wire 1 " cout $end
$var reg 4 # a [3:0] $end
$var reg 4 $ b [3:0] $end
$var reg 1 % cin $end
$scope module uut $end
$var wire 4 & a [3:0] $end
$var wire 4 ' b [3:0] $end
$var wire 1 % cin $end
$var wire 1 ( correction_needed $end
$var wire 4 ) sum [3:0] $end
$var wire 4 * raw_sum [3:0] $end
$var wire 1 " cout $end
$var wire 4 + corrected_sum [3:0] $end
$var wire 1 , carry_out $end
$var wire 1 - carry_correction $end
$scope module add1 $end
$var wire 4 . a [3:0] $end
$var wire 4 / b [3:0] $end
$var wire 1 % cin $end
$var wire 4 0 sum [3:0] $end
$var wire 1 , cout $end
$var wire 1 1 c3 $end
$var wire 1 2 c2 $end
$var wire 1 3 c1 $end
$scope module fa0 $end
$var wire 1 4 a $end
$var wire 1 5 b $end
$var wire 1 3 carry $end
$var wire 1 % cin $end
$var wire 1 6 sum $end
$upscope $end
$scope module fa1 $end
$var wire 1 7 a $end
$var wire 1 8 b $end
$var wire 1 2 carry $end
$var wire 1 3 cin $end
$var wire 1 9 sum $end
$upscope $end
$scope module fa2 $end
$var wire 1 : a $end
$var wire 1 ; b $end
$var wire 1 1 carry $end
$var wire 1 2 cin $end
$var wire 1 < sum $end
$upscope $end
$scope module fa3 $end
$var wire 1 = a $end
$var wire 1 > b $end
$var wire 1 , carry $end
$var wire 1 1 cin $end
$var wire 1 ? sum $end
$upscope $end
$upscope $end
$scope module add2 $end
$var wire 4 @ a [3:0] $end
$var wire 4 A b [3:0] $end
$var wire 1 B cin $end
$var wire 4 C sum [3:0] $end
$var wire 1 - cout $end
$var wire 1 D c3 $end
$var wire 1 E c2 $end
$var wire 1 F c1 $end
$scope module fa0 $end
$var wire 1 G a $end
$var wire 1 H b $end
$var wire 1 F carry $end
$var wire 1 B cin $end
$var wire 1 I sum $end
$upscope $end
$scope module fa1 $end
$var wire 1 J a $end
$var wire 1 K b $end
$var wire 1 E carry $end
$var wire 1 F cin $end
$var wire 1 L sum $end
$upscope $end
$scope module fa2 $end
$var wire 1 M a $end
$var wire 1 N b $end
$var wire 1 D carry $end
$var wire 1 E cin $end
$var wire 1 O sum $end
$upscope $end
$scope module fa3 $end
$var wire 1 P a $end
$var wire 1 Q b $end
$var wire 1 - carry $end
$var wire 1 D cin $end
$var wire 1 R sum $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
1R
0Q
1P
1O
1N
0M
1L
1K
0J
1I
0H
1G
0F
0E
0D
b1111 C
0B
b110 A
b1001 @
1?
0>
0=
0<
1;
1:
09
08
07
16
15
04
03
02
11
b1001 0
b101 /
b100 .
0-
0,
b1111 +
b1001 *
b1001 )
0(
b101 '
b100 &
0%
b101 $
b100 #
0"
b1001 !
$end
#20
1"
1-
0R
1D
1M
0O
1<
0E
1(
12
1L
b10 +
b10 C
0I
0J
0G
b10 !
b10 )
13
09
b1100 *
b1100 0
b1100 @
06
18
14
b111 $
b111 '
b111 /
b101 #
b101 &
b101 .
#40
1D
0"
1R
0-
b1000 !
b1000 )
1E
b1000 +
b1000 C
0L
0M
0P
0<
0?
1J
02
01
b10 *
b10 0
b10 @
19
1,
08
0;
1>
0:
1=
b1001 $
b1001 '
b1001 /
b1001 #
b1001 &
b1001 .
#60
0D
1R
0-
1P
0E
1?
1L
11
1O
b1000 !
b1000 )
0(
b1110 +
b1110 C
0I
0J
12
0M
0,
09
0<
0G
b1000 *
b1000 0
b1000 @
06
18
0>
04
1:
0=
1%
b11 $
b11 '
b11 /
b100 #
b100 &
b100 .
#80
1"
1-
1E
1D
0L
0O
b0 +
b0 C
0R
1J
02
0M
1P
b0 !
b0 )
1(
19
0<
01
b1010 *
b1010 0
b1010 @
1?
0,
05
08
14
0:
1=
b0 $
b0 '
b0 /
b1001 #
b1001 &
b1001 .
#100
b0 !
b0 )
1"
0O
b0 +
b0 C
0R
1-
1(
11
0M
1P
12
0<
b1010 *
b1010 0
b1010 @
1?
18
17
1:
0=
b10 $
b10 '
b10 /
b111 #
b111 &
b111 .
#120
